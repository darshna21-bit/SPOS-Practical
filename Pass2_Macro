package SLP1;
import java.io.*;
import java.util.*;

public class MacroPass2 {
		static Map<String, Integer> macroTable = new HashMap<>();
	    static List<String> MDTContent = new ArrayList<>();

	    public static void main(String[] args) throws IOException {
	        
	        // --- LOAD TABLES (Generated by Pass 1) ---
	        
	        // Load MNT
	        BufferedReader mntReader = new BufferedReader(new FileReader("mnt.txt"));
	        String line;
	        while ((line = mntReader.readLine()) != null) {
	            String[] parts = line.split("\t");
	            macroTable.put(parts[0], Integer.parseInt(parts[1]));
	        }
	        mntReader.close();

	        // Load MDT
	        BufferedReader mdtReader = new BufferedReader(new FileReader("mdt.txt"));
	        while ((line = mdtReader.readLine()) != null) {
	            MDTContent.add(line);
	        }
	        mdtReader.close();

	        // --- PROCESSING LOGIC ---
	        
	        BufferedReader input = new BufferedReader(new FileReader("intermediate.txt"));
	        BufferedWriter output = new BufferedWriter(new FileWriter("expanded_output.asm"));
	        BufferedWriter machineCode = new BufferedWriter(new FileWriter("machine_code.txt"));

	        while ((line = input.readLine()) != null) {
	            String[] parts = line.trim().split("\\s+");
	            
	            // Check if line is a Macro Call
	            if (macroTable.containsKey(parts[0])) {
	                String macroName = parts[0];
	                int mdtIndex = macroTable.get(macroName);
	                
	                // Collect actual arguments
	                List<String> actualArgs = new ArrayList<>();
	                for (int i = 1; i < parts.length; i++) {
	                    actualArgs.add(parts[i].replace(",", ""));
	                }
	                
	                // Expand Macro
	                List<String> expandedLines = expandMacro(mdtIndex, actualArgs, macroName);
	                for (String expLine : expandedLines) {
	                    output.write(expLine + "\n");
	                    writeMachineCode(machineCode, expLine);
	                }
	            } else {
	                // Normal Instruction
	                output.write(line + "\n");
	                writeMachineCode(machineCode, line);
	            }
	        }

	        input.close();
	        output.close();
	        machineCode.close();

	        // --- TERMINAL OUTPUT SECTION ---
	        System.out.println("\n******** MACRO PASS-II OUTPUT ********\n");

	        printFileContent("EXPANDED SOURCE CODE (expanded_output.asm)", "expanded_output.asm");
	        printFileContent("MOCK MACHINE CODE (machine_code.txt)", "machine_code.txt");
	    }

	    // Helper to Expand Macro
	    public static List<String> expandMacro(int mdtIndex, List<String> actualArgs, String macroName) throws IOException {
	        List<String> result = new ArrayList<>();
	        Map<String, String> alaMap = new LinkedHashMap<>();
	        
	        // Load ALA Template for this Macro
	        File alaFile = new File("ALA_" + macroName + ".txt");
	        if (!alaFile.exists()) return result;
	        
	        BufferedReader alaReader = new BufferedReader(new FileReader(alaFile));
	        String argName;
	        int argIndex = 0;

	        // Map Formal Args (from ALA file) to Actual Args (from code)
	        while ((argName = alaReader.readLine()) != null) {
	            String value = "";
	            if (argIndex < actualArgs.size()) {
	                String actual = actualArgs.get(argIndex);
	                // Handle Keyword Arguments (REG=CREG)
	                if (actual.contains("=")) {
	                    value = actual.split("=")[1];
	                } else {
	                    value = actual;
	                }
	            }
	            alaMap.put(argName, value);
	            argIndex++;
	        }
	        alaReader.close();

	        // Substitute Args in MDT lines
	        while (mdtIndex < MDTContent.size()) {
	            String mdtLine = MDTContent.get(mdtIndex);
	            if (mdtLine.equals("MEND")) break;

	            String[] tokens = mdtLine.split("\\s+");
	            StringBuilder expandedLine = new StringBuilder();

	            for (String token : tokens) {
	                String cleanToken = token.replace(",", "");
	                if (alaMap.containsKey(cleanToken)) {
	                    expandedLine.append(alaMap.get(cleanToken)).append(token.endsWith(",") ? ", " : " ");
	                } else {
	                    expandedLine.append(token).append(" ");
	                }
	            }
	            result.add(expandedLine.toString().trim());
	            mdtIndex++;
	        }
	        return result;
	    }

	    // Helper to generate Mock Machine Code
	    private static void writeMachineCode(BufferedWriter bw, String line) throws IOException {
	        if (line.trim().isEmpty()) return;
	        String[] parts = line.split("\\s+");
	        
	        // Mock Logic: Opcode hash, Reg hash, Address hash
	        String op = String.format("%02d", Math.abs(parts[0].hashCode() % 99));
	        String reg = (parts.length > 1) ? String.valueOf(Math.abs(parts[1].hashCode() % 9)) : "0";
	        String addr = (parts.length > 2) ? String.format("%03d", Math.abs(parts[2].hashCode() % 999)) : "000";
	        
	        bw.write(op + " " + reg + " " + addr + "\n");
	    }

	    // Helper method to read and print file content
	    private static void printFileContent(String title, String fileName) throws IOException {
	        System.out.println("------------------------------");
	        System.out.println("   " + title);
	        System.out.println("------------------------------");
	        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	            String line;
	            while ((line = br.readLine()) != null) {
	                System.out.println(line);
	            }
	        }
	        System.out.println(); 
	    }
	}
